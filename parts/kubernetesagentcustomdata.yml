#cloud-config

write_files:
- path: "/etc/systemd/system/docker.service.d/clear_mount_propagation_flags.conf"
  permissions: "0644"
  owner: "root"
  content: |
    [Service]
    MountFlags=shared

- path: "/etc/systemd/system/docker.service.d/exec_start.conf"
  permissions: "0644"
  owner: "root"
  content: |
    [Service]
    ExecStart=
    ExecStart=/usr/bin/docker daemon -H fd:// --storage-driver=overlay2 --bip={{WrapAsVariable "dockerBridgeCidr"}}

- path: "/etc/docker/daemon.json"
  permissions: "0644"
  owner: "root"
  content: |
    {
      "live-restore": true,
      "log-driver": "json-file",
      "log-opts":  {
          "max-size": "50m",
          "max-file": "5"
      }
    }

- path: "/etc/kubernetes/certs/ca.crt"
  permissions: "0644"
  encoding: "base64"
  owner: "root"
  content: |
    {{WrapAsVariable "caCertificate"}}

- path: "/etc/kubernetes/certs/apiserver.crt"
  permissions: "0644"
  encoding: "base64"
  owner: "root"
  content: |
    {{WrapAsVariable "apiserverCertificate"}}

- path: "/etc/kubernetes/certs/client.crt"
  permissions: "0644"
  encoding: "base64"
  owner: "root"
  content: |
    {{WrapAsVariable "clientCertificate"}}

- path: "/var/lib/kubelet/kubeconfig"
  permissions: "0644"
  owner: "root"
  content: |
    apiVersion: v1
    kind: Config
    clusters:
    - name: localcluster
      cluster:
        certificate-authority: /etc/kubernetes/certs/ca.crt
        server: https://{{WrapAsVariable "kubernetesAPIServerIP"}}:443
    users:
    - name: client
      user:
        client-certificate: /etc/kubernetes/certs/client.crt
        client-key: /etc/kubernetes/certs/client.key
    contexts:
    - context:
        cluster: localcluster
        user: client
      name: localclustercontext
    current-context: localclustercontext

- path: "/etc/systemd/system/kubectl-extract.service"
  permissions: "0644"
  owner: "root"
  content: |
    [Unit]
    Description=Kubectl extraction
    Requires=docker.service
    After=docker.service
    ConditionPathExists=!/usr/bin/kubectl
    [Service]
    TimeoutStartSec=0
    Restart=on-failure
    RestartSec=5s
    ExecStartPre=/bin/mkdir -p /tmp/kubectldir
    ExecStartPre=/usr/bin/docker pull {{WrapAsVariable "kubernetesHyperkubeSpec"}}
    ExecStartPre=/usr/bin/docker run --rm -v /tmp/kubectldir:/opt/kubectldir {{WrapAsVariable "kubernetesHyperkubeSpec"}} /bin/bash -c "cp /hyperkube /opt/kubectldir/"
    ExecStartPre=/bin/mv /tmp/kubectldir/hyperkube /usr/bin/kubectl
    ExecStart=/bin/chmod a+x /usr/bin/kubectl
    [Install]
    WantedBy=multi-user.target

- path: "/etc/default/kubelet"
  permissions: "0644"
  owner: "root"
  content: |
    KUBELET_CLUSTER_DNS={{WrapAsVariable "kubeDNSServiceIP"}}
    KUBELET_API_SERVERS=https://{{WrapAsVariable "kubernetesAPIServerIP"}}:443
    KUBELET_IMAGE={{WrapAsVariable "kubernetesHyperkubeSpec"}}
    KUBELET_NETWORK_PLUGIN=kubenet
    KUBELET_MAX_PODS=110
    KUBELET_OPTS=
    DOCKER_OPTS=
    CUSTOM_CMD=/bin/true
    KUBELET_REGISTER_SCHEDULABLE=true
    KUBELET_NODE_LABELS={{ GetKubernetesLabels . }}
    KUBELET_POD_INFRA_CONTAINER_IMAGE={{WrapAsVariable "kubernetesPodInfraContainerSpec"}}
    KUBELET_NODE_STATUS_UPDATE_FREQUENCY={{WrapAsVariable "kubernetesNodeStatusUpdateFrequency"}}
    KUBE_CTRL_MGR_NODE_MONITOR_GRACE_PERIOD={{WrapAsVariable "kubernetesCtrlMgrNodeMonitorGracePeriod"}}
    KUBE_CTRL_MGR_POD_EVICTION_TIMEOUT={{WrapAsVariable "kubernetesCtrlMgrPodEvictionTimeout"}}
    KUBE_CTRL_MGR_ROUTE_RECONCILIATION_PERIOD={{WrapAsVariable "kubernetesCtrlMgrRouteReconciliationPeriod"}}
    KUBELET_IMAGE_GC_HIGH_THRESHOLD={{WrapAsVariable "gchighthreshold"}}
    KUBELET_IMAGE_GC_LOW_THRESHOLD={{WrapAsVariable "gclowthreshold"}}
{{if IsKubernetesVersionGe "1.6.0"}}
    KUBELET_NON_MASQUERADE_CIDR=--non-masquerade-cidr={{WrapAsVariable "kubernetesNonMasqueradeCidr"}}
    KUBELET_FEATURE_GATES=--feature-gates=Accelerators=true
  {{if IsKubernetesVersionTilde "1.6.x"}}
    KUBELET_FIX_43704_1=--cgroups-per-qos=false
    KUBELET_FIX_43704_2=--enforce-node-allocatable=
    KUBELET_FIX_43704_3=""
  {{end}}
{{end}}

- path: "/etc/systemd/system/kubelet.service"
  permissions: "0644"
  encoding: gzip
  owner: "root"
  content: !!binary |
    KUBELET_SERVICE_B64_GZIP_STR

{{if eq .OrchestratorProfile.KubernetesConfig.ContainerRuntime "clear-containers"}}
- path: "/etc/systemd/system/crio.service"
  permissions: "0644"
  encoding: gzip
  owner: "root"
  content: !!binary |
    CRIO_SERVICE_B64_GZIP_STR

- path: "/etc/crio/crio.conf"
  permissions: "0755"
  encoding: gzip
  owner: "root"
  content: !!binary |
    CRIO_CONFIG_B64_GZIP_STR

- path: "/etc/containers/policy.json"
  permissions: "0644"
  owner: "root"
  content: |
    {
    "default": [{"type": "insecureAcceptAnything"}],
    "transports": { "docker-daemon": { "": [{"type":"insecureAcceptAnything"}] } }
    }
{{end}}

- path: "/opt/azure/containers/kubelet.sh"
  permissions: "0755"
  owner: "root"
  content: |
    #!/usr/bin/env bash
    {{if IsVNETIntegrated}}
    # SNAT outbound traffic from pods to destinations outside of VNET.
    iptables -t nat -A POSTROUTING -m iprange ! --dst-range 168.63.129.16 -m addrtype ! --dst-type local ! -d {{WrapAsVariable "vnetCidr"}} -j MASQUERADE
    {{end}}
    exit 0

{{if .IsClearLinux}}
- path: "/opt/azure/containers/fix.sh"
  permissions: "0755"
  owner: "root"
  content: |
    #!/usr/bin/env bash
    # update the package manager
    swupd update
    tmpdir="$(mktemp -d)"
    base64files=( "/etc/kubernetes/certs/ca.crt" "/etc/kubernetes/certs/apiserver.crt" "/etc/kubernetes/certs/client.crt" )
    gzipfiles=( "/etc/kubernetes/manifests/kube-apiserver.yaml" "/etc/kubernetes/manifests/kube-controller-manager.yaml" "/etc/kubernetes/manifests/kube-scheduler.yaml" "/etc/systemd/system/kubelet.service" "/etc/systemd/system/crio.service" "/etc/crio/crio.conf" "/opt/azure/containers/provision.sh" "/opt/azure/containers/docker.sh" )
    # base64 decode the files
    for f in "${base64files[@]}"; do
      if [[ -f "$f" ]]; then
        base=$(basename "$f")
        cat "$f" | base64 -d > "${tmpdir}/${base}"
        cat "${tmpdir}/${base}" > "$f"
      fi
    done
    # gzip decode the files
    for f in "${gzipfiles[@]}"; do
      if [[ -f "$f" ]]; then
        base=$(basename "$f")
        cat "$f" | base64 -d | gzip -d > "${tmpdir}/${base}"
        cat "${tmpdir}/${base}" > "$f"
      fi
    done
    rm -rf "$tmpdir"
    /opt/azure/containers/run.sh
  {{end}}

- path: "/opt/azure/containers/docker.sh"
  permissions: "0755"
  encoding: gzip
  owner: "root"
  content: !!binary |
    INSTALL_DOCKER_SCRIPT

- path: "/opt/azure/containers/provision.sh"
  permissions: "0744"
  encoding: gzip
  owner: "root"
  content: !!binary |
    {{WrapAsVariable "provisionScript"}}

- path: "/opt/azure/containers/run.sh"
  permissions: "0755"
  owner: "root"
  content: |
    #!/usr/bin/env bash

    usermod -aG docker {{WrapAsVariable "username"}}

    touch /opt/azure/containers/runcmd.complete


{{if not .IsClearLinux}}
runcmd: {{GetKubernetesAgentPreprovisionYaml .}}
- /opt/azure/containers/docker.sh {{WrapAsVariable "dockerEngineDownloadRepo"}}
- systemctl enable rpcbind rpc-statd
- systemctl start rpcbind rpc-statd
{{GetGPUDriversInstallScript .}}
{{end}}
